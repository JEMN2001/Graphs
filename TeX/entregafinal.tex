\documentclass[conference]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-tabla]{babel}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Implementación de la clase \texttt{Graph} en \texttt{C++}*\\
{\footnotesize \textsuperscript{*}Junto a algunos algoritmos conocidos en la teoría de grafos no dirigidos.}
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{Víctor Samuel Pérez Díaz}
\IEEEauthorblockA{\textit{Matemáticas Aplicadas y Ciencias de la Computación} \\
\textit{Universidad del Rosario}\\
Bogotá D.C., Colombia\\
victor.perez@urosario.edu.co}
\and
\IEEEauthorblockN{Juan Esteban Murcia Nieto}
\IEEEauthorblockA{\textit{Matemáticas Aplicadas y Ciencias de la Computación} \\
\textit{Universidad del Rosario}\\
Bogotá D.C., Colombia \\
juane.murcia@urosario.edu.co}
}


\maketitle

\begin{IEEEkeywords}
grafo, algoritmo, nodo, arista, matriz
\end{IEEEkeywords}

\section{Introducción}
Este documento busca exponer una implementación de la clase \texttt{Graph} en el lenguaje de programación \texttt{C++}. Junto a esta, se realizaron varios algoritmos conocidos en la teoría de grafos no dirigidos. \texttt{C++}.

\section{Resumen}

Este proyecto se realizó con los ánimos de tener una representación de grafos no dirigidos. Junto a esta, también se realizaron varios algoritmos clásicos enseñados en nuestro curso de \textit{Teoría de Grafos}, junto a algunos que investigamos por nuestra cuenta. 

La clase Graph se basa en la matriz de adyacencia de un grafo no dirigido. Todos los algoritmos fueron construidos en base a esta.

Por tanto, la clase \texttt{Graph} cuenta con tan solo un parámetro \texttt{matrix}, en el cual se almacena la matriz de adyacencia.

Los métodos desarrollados fueron: 
\begin{itemize}
	\item \texttt{Graph} \textit{y sus derivados.}
	
	\item \texttt{uncolored\_vertex}
	
	\item \texttt{colored\_vertex}
	
	\item \texttt{colored\_neighbor}
	
	\item \texttt{uv\_path}
	
	\item \texttt{grade}
	
	\item \texttt{empty}
	
	\item \texttt{order}
	
	\item \texttt{size}
	
	\item \texttt{max\_grade}
	
	\item \texttt{min\_grade}
	
	\item \texttt{remove\_node}
	
	\item \texttt{remove\_edge}
	
	\item \texttt{add\_node}
	
	\item  \texttt{add\_edge}
	
	\item \texttt{clear}
	
	\item \texttt{print\_matrix}
	
	\item \texttt{find\_path}
	
	\item \texttt{color\_graph}
	
	\item \texttt{breadth\_search}
	
	\item \texttt{depth\_search}
	
	\item \texttt{shortest\_uv\_path}
	
	Cada uno de los anteriores será explicado en la sección \textbf{Funcionalidad}.
\end{itemize} 
\section{Funcionalidad}

La clase \texttt{Graph} está basada en la matriz de adyacencia de un grafo no dirigido, esta siendo su único parámetro. 

El primer acercamiento a la idea de la clase fue crear dos estructuras \texttt{nodos (V)} y \texttt{aristas (E)}, la construcción resulta ser conflictiva al hacer uso de punteros, los cuales interactuan con la memoria del computador. Dado esto, encontramos que la implementación a través de la matriz resultaba mucho más práctica.

Se desarrollaron varias versiones del constructor \texttt{Graph}:
\begin{itemize}
	\item \texttt{Graph()}: Constructor vacío, un grafo sin nodos ni aristas.
	
	\item \texttt{Graph(Graph)}: Constructor copia.
	
	\item \texttt{Graph(A\_matrix)}: Construye un grafo con una matriz de adyacencia específica.
	
	\item \texttt{Graph(filename)}: Construye un grafo con una matriz de adyacencia específica contenida en un archivo \texttt{.txt}.
\end{itemize}  

También, se realizó el método destructor:

\begin{itemize}
	\item \texttt{$\thicksim$Graph()}: Destructor de la clase.
\end{itemize} 

En la \textbf{sección privada} de la clase, se definió el parámetro:
\begin{itemize}
	\item \texttt{matrix}: Matriz de adyacencia del grafo.
	
\end{itemize}

Y además, se definieron los siguientes métodos: 
\begin{itemize}
	
	\item \texttt{uncolored\_vertex}: Función que determina si un vértice no tiene color dada una coloración.

	\item \texttt{colored\_neighbor}: Función que determina si un vértice tiene un vecino con un color dado.
	
	\item \texttt{uv\_path}: Función que determina si hay un $uv-$camino en el grafo.
\end{itemize}

Ahora, en la \textbf{sección pública}, se definieron los siguientes métodos  (junto a los constructores y destructor de la clase, definidos arriba):

\begin{itemize}


	\item \texttt{grade}: Función que calcula el grado de un vértice.

	\item \texttt{empty}: Función que determina si un grafo no tiene vértices.

	\item \texttt{order}: Función que nos da el número de vértices del grafo.

	\item \texttt{size}: Función que nos da el número de aristas del grafo.

	\item \texttt{max\_grade}: Función que nos da el máximo grado del grafo.

	\item \texttt{min\_grade}: Función que nos dale el mínimo grado del grafo.

	\item \texttt{remove\_node}: Función que remueve un vértice específico y todas sus aristas adyacentes.

	\item \texttt{remove\_edge}: Función que remueve una arista específica del grafo.
	
	\item \texttt{add\_node}: Función que inserta un vértice nuevo al grafo.

	\item  \texttt{add\_edge}: Función que inserta una nueva arista al grafo.

	\item \texttt{clear}: Limpia el grafo.

	\item \texttt{print\_matrix}: Función que muestra la matriz de adyacencia del grafo.

	\item \texttt{find\_path}: Función que determina si hay un camino euleriano en el grafo y en caso afirmativo, lo encuentra.
	
	\item \texttt{color\_graph}: Función que da un coloreado apropiado a los vértices.
	
	\item \texttt{breadth\_search}: Función que retorna un árbol de expansión del grafo usando el algoritmo de búsqueda a lo ancho.
	
	\item \texttt{depth\_search}: Función que retorna un árbol de expansión del grafo usando el algoritmo de búsqueda a profundidad.
	
	\item \texttt{shortest\_uv\_path}: Función que usa el algoritmo de Dijkstra para encontrar el menor $u,v-$camino en el grafo.
\end{itemize}


\section{Descripción}
En esta sección, se describirán los algoritmos que consideramos más relevantes, además, dados los análisis hechos a algunos de ellos, indicaremos su complejidad si es el caso:
\begin{itemize}
\item \texttt{find\_path}: Lo primero que hace el algoritmo es contar la cantidad de vértices que tengan grado impar, si estos son mayores a 2, retorna una lista vacia, de lo contrario toma como inicio uno de los vértices de grado impar (cualquier vértice si no hay vértices de grado impar) recorre una arista hacia otro vértice, elimina la arista que recorrió y repite el proceso hasta que llegue a un vértice sin más aristas, al llegar añadirá ese vértice al camino y se devolverá al anterior, repitiendo el proceso hasta que no se pueda devolver más. \\ \textbf{Complejidad}: $\mathcal{O}(N+E)$
\item \texttt{color\_graph}: Inicializa todos los nodos con color 0 (sin color) y mientras haya un vértice sin color, recorrera todos los vértices, si el vértice actual no tiene color y ninguno de sus vecinos tiene ese color, le asignara ese color a ese vértice, si acaba la iteración y siguen habiendo vértices sin color, cambia el color y repite el proceso.\\ \textbf{Complejidad}: $\mathcal{O}(N^3)$
\item \texttt{breadth\_search}: Crea un nuevo grafo con la misma cantidad de vértices que el grafo de entrada, luego recorrerá los vértices de ese grafo, revisará la conexión del vértice actual con el resto de vértices, y agregará una arista entre un par de vértices en el grafo de salida, si esa arista está en el grafo de entrada y no existe ya un camino entre esos vértices en el grafo de salida.\\
\item \texttt{depth\_search}: Crea un nuevo grafo con la misma cantidad de vértices que el grafo de entrada, luego recorrerá todos los vertices de ese grafo, si encuentra una arista en el grafo de entrada que no este en el grafo de salida y no haya un camino entre esos dos vértices en el grafo de salida, agregará la arista y avanzará al siguiente vértice.\\
\item \texttt{shortest\_uv\_path}: Lo primero que hace es el algoritmo es determinar si ambos vértices pertenecen al grafo, si esto no ocurre, soltara un mensaje de error y retornará una lista vacía. De lo contrario inicializa una lista de valores con 0 en el vértice de inicio e infinito en el resto de vértices, un conjunto con los vertices que puedo chequear y una lista con el camino que se debe tomar inicializada con infinito. Mientras el vértice de llegada siga en el conjunto, selecciona el vértice con menor valor en la lista de valores, eliminará ese vértice del cunjunto y recorrerá todos los vértices del grafo, si encuentra que uno de los nodos es adyacente con el nodo actual y el valor del vértice en la lista de valores más 1 es menor al valor actual del vértice de la iteración, actualizo el valor por el menor y repito. Una vez termine, armará el camino y lo retornará. \textbf{Complejidad}: $\mathcal{O}(N^2)$
\end{itemize}
\section{Conclusiones}

\section*{Acknowledgment}

The preferred spelling of the word ``acknowledgment'' in America is without 
an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. 
G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor 
acknowledgments in the unnumbered footnote on the first page.

\section*{References}

Please number citations consecutively within brackets \cite{b1}. The 
sentence punctuation follows the bracket \cite{b2}. Refer simply to the reference 
number, as in \cite{b3}---do not use ``Ref. \cite{b3}'' or ``reference \cite{b3}'' except at 
the beginning of a sentence: ``Reference \cite{b3} was the first $\ldots$''

Number footnotes separately in superscripts. Place the actual footnote at 
the bottom of the column in which it was cited. Do not put footnotes in the 
abstract or reference list. Use letters for table footnotes.

Unless there are six authors or more give all authors' names; do not use 
``et al.''. Papers that have not been published, even if they have been 
submitted for publication, should be cited as ``unpublished'' \cite{b4}. Papers 
that have been accepted for publication should be cited as ``in press'' \cite{b5}. 
Capitalize only the first word in a paper title, except for proper nouns and 
element symbols.

For papers published in translation journals, please give the English 
citation first, followed by the original foreign-language citation \cite{b6}.

\begin{thebibliography}{00}
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
\bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
\bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
\bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
\bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
\bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
\bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
\end{thebibliography}
\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
