\documentclass[conference]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-tabla]{babel}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Implementación de la clase \texttt{Graph} en \texttt{C++}*\\
{\footnotesize \textsuperscript{*}Junto a algunos algoritmos conocidos en la teoría de grafos no dirigidos.}
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{Víctor Samuel Pérez Díaz}
\IEEEauthorblockA{\textit{Matemáticas Aplicadas y Ciencias de la Computación} \\
\textit{Universidad del Rosario}\\
Bogotá D.C., Colombia\\
victor.perez@urosario.edu.co}
\and
\IEEEauthorblockN{Juan Esteban Murcia Nieto}
\IEEEauthorblockA{\textit{Matemáticas Aplicadas y Ciencias de la Computación} \\
\textit{Universidad del Rosario}\\
Bogotá D.C., Colombia \\
juane.murcia@urosario.edu.co}
}


\maketitle

\begin{IEEEkeywords}
grafo, algoritmo, nodo, arista, matriz
\end{IEEEkeywords}

\textbf{Repositorio:} \url{https://github.com/JEMN2001/Graphs}
\section{Introducción}
Este documento busca exponer una implementación de la clase \texttt{Graph} en el lenguaje de programación \texttt{C++}. Junto a esta, se realizaron varios algoritmos conocidos en la teoría de grafos no dirigidos. \texttt{C++}.

\section{Resumen}

Este proyecto se realizó con los ánimos de tener una representación de grafos no dirigidos. Junto a esta, también se realizaron varios algoritmos clásicos enseñados en nuestro curso de \textit{Teoría de Grafos}, junto a algunos que investigamos por nuestra cuenta. 

La clase Graph se basa en la matriz de adyacencia de un grafo no dirigido. Todos los algoritmos fueron construidos en base a esta.

Por tanto, la clase \texttt{Graph} cuenta con tan solo un parámetro \texttt{matrix}, en el cual se almacena la matriz de adyacencia.

Los métodos desarrollados fueron: 
\begin{itemize}
	\item \texttt{Graph} \textit{y sus derivados.}
	
	\item \texttt{uncolored\_vertex}
	
	\item \texttt{colored\_vertex}
	
	\item \texttt{colored\_neighbor}
	
	\item \texttt{uv\_path}
	
	\item \texttt{grade}
	
	\item \texttt{empty}
	
	\item \texttt{order}
	
	\item \texttt{size}
	
	\item \texttt{max\_grade}
	
	\item \texttt{min\_grade}
	
	\item \texttt{remove\_node}
	
	\item \texttt{remove\_edge}
	
	\item \texttt{add\_node}
	
	\item  \texttt{add\_edge}
	
	\item \texttt{clear}
	
	\item \texttt{print\_matrix}
	
	\item \texttt{find\_path}
	
	\item \texttt{color\_graph}
	
	\item \texttt{breadth\_search}
	
	\item \texttt{depth\_search}
	
	\item \texttt{shortest\_uv\_path}
	
	Cada uno de los anteriores será explicado en la sección \textbf{Funcionalidad}.
\end{itemize} 
\section{Funcionalidad}

La clase \texttt{Graph} está basada en la matriz de adyacencia de un grafo no dirigido, esta siendo su único parámetro. 

El primer acercamiento a la idea de la clase fue crear dos estructuras \texttt{nodos (V)} y \texttt{aristas (E)}, la construcción resulta ser conflictiva al hacer uso de punteros, los cuales interactuan con la memoria del computador. Dado esto, encontramos que la implementación a través de la matriz resultaba mucho más práctica.

Se desarrollaron varias versiones del constructor \texttt{Graph}:
\begin{itemize}
	\item \texttt{Graph()}: Constructor vacío, un grafo sin nodos ni aristas.
	
	\item \texttt{Graph(Graph)}: Constructor copia.
	
	\item \texttt{Graph(A\_matrix)}: Construye un grafo con una matriz de adyacencia específica.
	
	\item \texttt{Graph(filename)}: Construye un grafo con una matriz de adyacencia específica contenida en un archivo \texttt{.txt}.
\end{itemize}  

También, se realizó el método destructor:

\begin{itemize}
	\item \texttt{$\thicksim$Graph()}: Destructor de la clase.
\end{itemize} 

En la \textbf{sección privada} de la clase, se definió el parámetro:
\begin{itemize}
	\item \texttt{matrix}: Matriz de adyacencia del grafo.
	
\end{itemize}

Y además, se definieron los siguientes métodos: 
\begin{itemize}
	
	\item \texttt{uncolored\_vertex}: Función que determina si un vértice no tiene color dada una coloración.

	\item \texttt{colored\_neighbor}: Función que determina si un vértice tiene un vecino con un color dado.
	
	\item \texttt{uv\_path}: Función que determina si hay un $uv-$camino en el grafo.
\end{itemize}

Ahora, en la \textbf{sección pública}, se definieron los siguientes métodos  (junto a los constructores y destructor de la clase, definidos arriba):

\begin{itemize}


	\item \texttt{grade}: Función que calcula el grado de un vértice.

	\item \texttt{empty}: Función que determina si un grafo no tiene vértices.

	\item \texttt{order}: Función que nos da el número de vértices del grafo.

	\item \texttt{size}: Función que nos da el número de aristas del grafo.

	\item \texttt{max\_grade}: Función que nos da el máximo grado del grafo.

	\item \texttt{min\_grade}: Función que nos dale el mínimo grado del grafo.

	\item \texttt{remove\_node}: Función que remueve un vértice específico y todas sus aristas adyacentes.

	\item \texttt{remove\_edge}: Función que remueve una arista específica del grafo.
	
	\item \texttt{add\_node}: Función que inserta un vértice nuevo al grafo.

	\item  \texttt{add\_edge}: Función que inserta una nueva arista al grafo.

	\item \texttt{clear}: Limpia el grafo.

	\item \texttt{print\_matrix}: Función que muestra la matriz de adyacencia del grafo.

	\item \texttt{find\_path}: Función que determina si hay un camino euleriano en el grafo y en caso afirmativo, lo encuentra.
	
	\item \texttt{color\_graph}: Función que da un coloreado apropiado a los vértices.
	
	\item \texttt{breadth\_search}: Función que retorna un árbol de expansión del grafo usando el algoritmo de búsqueda a lo ancho.
	
	\item \texttt{depth\_search}: Función que retorna un árbol de expansión del grafo usando el algoritmo de búsqueda a profundidad.
	
	\item \texttt{shortest\_uv\_path}: Función que usa el algoritmo de Dijkstra para encontrar el menor $u,v-$camino en el grafo.
\end{itemize}


\section{Descripción}
En esta sección, se describirán los algoritmos que consideramos más relevantes, además, dados los análisis hechos a algunos de ellos, indicaremos su complejidad si es el caso:
\begin{itemize}
\item \texttt{find\_path}: Lo primero que hace el algoritmo es contar la cantidad de vértices que tengan grado impar, si estos son mayores a 2, retorna una lista vacia, de lo contrario toma como inicio uno de los vértices de grado impar (cualquier vértice si no hay vértices de grado impar) recorre una arista hacia otro vértice, elimina la arista que recorrió y repite el proceso hasta que llegue a un vértice sin más aristas, al llegar añadirá ese vértice al camino y se devolverá al anterior, repitiendo el proceso hasta que no se pueda devolver más. \\ \textbf{Complejidad}: $\mathcal{O}(N+E)$
\item \texttt{color\_graph}: Inicializa todos los nodos con color 0 (sin color) y mientras haya un vértice sin color, recorrera todos los vértices, si el vértice actual no tiene color y ninguno de sus vecinos tiene ese color, le asignara ese color a ese vértice, si acaba la iteración y siguen habiendo vértices sin color, cambia el color y repite el proceso.\\ \textbf{Complejidad}: $\mathcal{O}(N^3)$
\item \texttt{breadth\_search}: Crea un nuevo grafo con la misma cantidad de vértices que el grafo de entrada, luego recorrerá los vértices de ese grafo, revisará la conexión del vértice actual con el resto de vértices, y agregará una arista entre un par de vértices en el grafo de salida, si esa arista está en el grafo de entrada y no existe ya un camino entre esos vértices en el grafo de salida.\\
\item \texttt{depth\_search}: Crea un nuevo grafo con la misma cantidad de vértices que el grafo de entrada, luego recorrerá todos los vertices de ese grafo, si encuentra una arista en el grafo de entrada que no este en el grafo de salida y no haya un camino entre esos dos vértices en el grafo de salida, agregará la arista y avanzará al siguiente vértice.\\
\item \texttt{shortest\_uv\_path}: Lo primero que hace es el algoritmo es determinar si ambos vértices pertenecen al grafo, si esto no ocurre, soltara un mensaje de error y retornará una lista vacía. De lo contrario inicializa una lista de valores con 0 en el vértice de inicio e infinito en el resto de vértices, un conjunto con los vertices que puedo chequear y una lista con el camino que se debe tomar inicializada con infinito. Mientras el vértice de llegada siga en el conjunto, selecciona el vértice con menor valor en la lista de valores, eliminará ese vértice del cunjunto y recorrerá todos los vértices del grafo, si encuentra que uno de los nodos es adyacente con el nodo actual y el valor del vértice en la lista de valores más 1 es menor al valor actual del vértice de la iteración, actualizo el valor por el menor y repito. Una vez termine, armará el camino y lo retornará. \textbf{Complejidad}: $\mathcal{O}(N^2)$
\end{itemize}
\section{Conclusiones}

La realización de la estructura de datos \texttt{Graph} no fue en especial complicada, sin embargo, el desarrollo de los algoritmos fue una misión de destreza.

La mayoría de algoritmos que implementamos y analizamos resultan de carácter polinómico, sin embargo hay algunos algoritmos en la teoría de grafos que no pueden ser resueltos en tiempos polinómicos. 

Además, experimentamos como la teoría de grafos es un amplio campo de estudio matemático en el cual las ciencias de la computación pueden explorar de una manera profunda.

\begin{thebibliography}{00}
\bibitem{b1} West, D. B. (2005). Introduction to graph theory. New Delhi: Prentice-Hall of India Private Limited. 
\bibitem{b2} A computer science portal for geeks. (n.d.). Retrieved from https://www.geeksforgeeks.org/ 
\end{thebibliography}
\vspace{12pt}
\color{red}
\end{document}
